## Chapter 1
#### 1-1
- 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.
- a는 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이다.
#### 1-2
- 선언 과정 이후 할당하는 과정입니다.
- a의 주소를 검색해서 그곳에 문자열 'abc'를 할당합니다.
- 다만 실제로 문자열을 저장하지는 않습니다.
#### 1-3
- 데이터영역 메모지를 통해 불변성 여부를 구분한다.
- 4번째 줄에서 변수 b에 숫자 5를 할당합니다. 이후 5를 찾으며 없으면 데이터 공간을 하나 만들어 저장합니다.
- 5와 7 모두 다른 값으로 변경이 불가능합니다.
#### 1-4
- 객체의 변수 영역이 별도로 존재합니다.
- 변수 obj1은 실제 데이터가 저장된 메모리 주소를 참조한다.
- 참조형은 변수에 주소값이 저장됩니다.
#### 1-5
- 참조형 데이터 변경하는 예제입니다.
- 객체의 프로퍼티 a의 값을 직접 변경한다.
- 새로운 객체로 재할당하지 않는 한 같은 객체를 가리킵니다.
#### 1-6
- 객체 내부의 배열이나 객체도 모두 별도의 참조형 메모리 구조를 가지고 있습니다.
- 참조형 안에 또 다른 참조형이 있으면 얕은 복사/깊은 복사 구분이 중요합니다.
#### 1-7
- obj2 는 기본형이 아니므로 주소를 통해 명명해야 합니다.
#### 1-8
- obj2.c 는 property를 변경하는 경우 위에 c 아래 d 가 바뀝니다.(가변)
- 내부 값을 변경하면 공유된 객체 전체에 영향을 줍니다.
#### 1-9
- obj2에 새로운 객체가 할당되며, 더 이상 obj1과 연결되지 않습니다.
- 참조형 변수는 새로운 객체를 할당하면 주소도 바뀝니다.
#### 1-10
- 참조형 데이터의 '가변'은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립합니다.
- 새로운 데이터를 할당하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않습니다.
#### 1-11
- 새로운 객체 리터럴을 직접 생성해서 반환함으로써 user와 user2는 다른 주소를 갖는다.
-Jung이 new name으로 새로운 object를 만들고 그 주소를 return 합니다.
#### 1-12
- 단순 복사이기 때문에 중첩 객체나 배열은 주소만 복사하는것이 얕은 복사이며 이것을 Shellowcopy라고 부르기도한다.
- result에 새로운 object의 주소를 return합니다.
#### 1-13
- user2는 user와는 별개의 객체이며 user에 중첩 객체가 있다면 공유될 수 있습니다.
#### 1-14
- 중첩된 객체까지 복사하려면 깊은 복사 필요성을 확인 가능한 예제입니다.
- Jaenam으로 user2가 가르키며 그 이후 Jung을 가르키고 있습니다.
#### 1-15
- old는 변하지 않고 new는 변합니다.
- 단계마다 복사함으로써 참조부분의 공유를 방지합니다.
#### 1-16
- result = target 부분이 deepcopy의 핵심입니다.
#### 1-17
- obj2.b.c 변경 하여도 obj에는 영향이 없습니다.
- obj.b.d[1] = 3 변경시에는 obj2의 d는 원본 배열이므로 영향을 받습니다.
#### 1-18
- __proto__나 getter/srtter들은 copy가 불가능 합니다.
- object target이 string으로 바뀝니다.
#### 1-19
- undefined는 값을 대입하지 않는 변수에 접근합니다.
- 반환 값이 없으면 undefined를 반환한 것으로 간주합니다.
#### 1-20
- 08번 라인처럼 사용하지 않습니다.
#### 1-21
- undefined는 없는것이 아닌 주소로 인식합니다.
- arr1.map은 새로운 array를 만듭니다.
- forEach, map, filter, reduce는 속에 들어있는 function을 적용하는 것 입니다.
#### 1-22
- typeof는 null이거나 object이며 이는 자바스크립트 자체 버그입니다.


## Chapter 2
#### 2-1
- inner 수행 끝나면 없어지며 그 이후 outer도 끝나며 이것 또한 제거 됩니다.
- inner() 함수 내부에서는 지역 변수 a가 호이스팅되어 undefined가 출력됩니다.
- console.log(a) 위치 이전에 var a가 선언되었기 때문에 outer() 바깥의 a는 global이며 outer() 내부에서는 a를 수정하지 않으므로 여전히 1입니다.
#### 2-2
- a()는 괄호 안을 수행하며 ()없으면 자체적으로 수행하지 않습니다.
- x에 1을 넣는것은 var x 에 넣는것과 동일합니다.
#### 2-3
- 변수는 한 번만 선언되며, 이후 var x;는 무의미하며 값을 덮어씌워질 수 있습니다.
- var는 중복 선언은 무시됩니다.
#### 2-4
- 모든 var x 선언은 통합됩니다.
- var 선언은 중복이 가능하지만 의미가 없으며 재할당만 의미를 가집니다.
#### 2-5
- 동일 이름일 경우 변수 할당이 우선 적용됩니다.
- function b() { }에의해 var b 가 없어지며 그후 b='bbb'로 재할당 됩니다.
#### 2-6
- 함수 선언문 b()는 전체가 호이스팅되고, 변수 b는 선언만 호이스팅됩니다.
- 함수 선언이 변수보다 우선 적용되며 변수 할당으로 값이 문자열로 덮임이 나타납니다.
#### 2-7
- b = function b() {}는 함수 표현식이며 변수 b에 함수 객체가 할당
- 최종적으로 b는 문자열 'bbb'로 나타납니다.
#### 2-8
- a는 함수선언문이며 전체를 호이스팅 합니다.
- b는 익명 함수 표현식으로 b변수만 호이스팅 합니다.
- c는 기명 함수 표현식으로 d는 내부 스코프에서만 사용이 가능합니다.
#### 2-9
- 04~06라인은 함수선언 형식으로는 추천하지 않는 형식입니다.
- 08~10라인 처럼 함수선언을 해야합니다.
- 함수 표현식은 선언 후 호출해야 안전합니다.
#### 2-10
- sum은 변수에 함수 객체를 할당한 것일 뿐, 호이스팅 시점에서는 undefined합니다.
- multiply는 선언만 호이스팅되고, 할당 전 호출되었기 때문에 에러가 발생합니다.
#### 2-11
-전체 hoisting 선언을 해야하며 hoisting이 끝난후 다시 처음부터 다시 수행이 일어납니다.
- 실제로는 함수 선언문이 중복될 경우 마지막 선언이 적용되며 실제로 hosting떄문에 1+2=3으로 나타나지 않습니다.
#### 2-12
- console.log(sum(3, 4));는 sum이 아직 함수가 아니므로 TypeError 발생합니다.(hoisting 후 바로 에러 발생)
#### 2-13
- 스코프 체인은 내부를 찾아서 없을경우 외부 체인에서 찾습니다.
- 호이스팅된 선언은 undefined로 초기화 됩니다.
#### 2-14
- console.dir(inner)은 함수 객체를 콘솔에 출력
#### 2-15
- 클로저란 외부 함수의 변수에 접근하는 내부함수 입니다.
- inner()는 outer()의 변수 b에 접근 가능하여 클로저가 형성이 됩니다.
#### 2-16
- outer() 함수가 호출되면 b = 2가 선언되고 할당하며 inner() 함수가 실행되면 외부 스코프에 선언된 b에서 2를 출력합니다.


## Chapter 3
#### 3-1
- this는 window 객체를 참조합니다.
- 전역에서 선언된 변수와 함수는 자동으로 window에 속하게 됩니다.
#### 3-2
- this는 {} 이며, 빈 객체입니다.
- global은 브라우저의 window 역할을 대신합니다.
#### 3-3
- var로 선언된 전역 변수는 window 객체의 프로퍼티로 등록합니다. 따라서 모두 같은 값을 가집니다.
#### 3-4
- window.변수 = 값 형태로 직접 정의된 프로퍼티는 delete 가능합니다.
#### 3-5
- var로 만든 전역 변수는 delete로 지울 수 없습니다.
#### 3-6
- func(1)은 일반 함수 호출하며 브라우저에선 this와 window가 같습니다.
- obj.method(2)은 메서드 호출하며 this와 obj가 같습니다. 따라서 this는 함수 호출 방식에 따라 결정됩니다.
#### 3-7
- method 안에 this가 숨어져 있으며 이 this는 obj를 가르키고 있습니다.
#### 3-8
- this는 정의된 위치가 아닌, 호출된 위치에 의해 결정됩니다.
#### 3-9
- function도 각자의 this를 가지고 있습니다.
- 일반 호출이라면 this는 전역 객체입니다.